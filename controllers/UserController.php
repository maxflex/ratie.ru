<?php	// Контроллер пользователей	class UserController extends Controller	{		public $defaultAction = "UserPage";				// Папка вьюх		protected $_viewsFolder	= "user";				// Перед выполнением любого действия, проверяем не был ли изменен пароль		public function beforeAction()		{			// Проверяем, залогинен ли пользователь			if (User::loggedIn()) {				// Проверяем не изменился ли пароль (если сменился на одном девайсе, то на всех других выходим)				if (User::fromSession(false, true)->token != mb_strimwidth($_COOKIE["ratie_token"], 0, 32)) {					$this->redirect("logout");				}			} else {				// Пытаемся войти по token в КУКАХ				User::rememberMeLogin(false);			}		}				// Отображение страницы пользователя		public function actionUserPage()		{				// Получаем пользователя, страница которого просматривается!!!			$ViewedUser = User::findByLogin($_GET["user"]);									// Получаем залогиненного пользователя			$LoggedUser = User::fromSession(false);						$_SESSION["viewing_id"] = $ViewedUser->id;											// Своя страница?			$own_page = $LoggedUser->id == $ViewedUser->id;									/******* CТРАНИЦА КОММЕНТАРИЕВ ********/						if (isset($_GET["comment"])) {							$this->addJs("user_comments"); // Включаем JS								// Получаем ID прилагательного				$id_adjective = (int)$_GET["comment"];								// Находим комментируемое прилагательное				$Adjective = Adjective::findById($id_adjective);								// Устанавливаем заголовок				$this->htmlTitle("Комментарии к «{$Adjective->adjective}» | ".$ViewedUser->getName());								// Получаем комментарии				$Comments = $Adjective->getComments();								// Если пользователь залогинен				if (User::loggedIn()) {										// Сообщения после регистрации о публичности (код сообщения для ангуляра - 1)					if (!$LoggedUser->intro["comment_public"] && !$LoggedUser->anonymous) {						$_intro_for_anonymous_or_public = 1;						$LoggedUser->intro["comment_public"] = 1;						$LoggedUser->save();					}													// Сообщения после регистрации об анонимности (код сообщения для ангуляра - 2)					if (!$LoggedUser->intro["comment_anonymous"] && $LoggedUser->anonymous) {						$_intro_for_anonymous_or_public = 2;						$LoggedUser->intro["comment_anonymous"] = 1;						$LoggedUser->save();					}				}								// Если пользователь залогинен и не анонимен				if (User::loggedIn() && !User::fromSession(false)->anonymous) {					// Пользователь, который будет передаваться на страницу рендера комментариев					$PassUser = (object)[						"id"	  => $LoggedUser->id,						"login"	  => $LoggedUser->login,						"avatar"  => $LoggedUser->avatar,						"stretch" => $LoggedUser->stretch,					];				} else {					$PassUser = (object)[						"id"	  => 0,						"login"	  => "",						"avatar"  => "img/profile/noava.png",						"stretch" => false,					];									}								// Если пользователь залогинен и не совя страница -- проверяем подписку				if (User::loggedIn() && !$own_page) {					// Проверяем подписан ли залогиненынй пользователь на пользователя, чья страница просматривается					$subscribed = User::fromSession()->subscribedTo($ViewedUser->id);				}								$this->render("comments", array(					"own_page"		=> $own_page,					"User"			=> $ViewedUser,					"LoggedUser"	=> $PassUser,					"Adjective"		=> $Adjective,					"Comments"		=> $Comments,					"subscribed"	=> $subscribed,					"id_viewing"	=> $ViewedUser->id,					"id_adjective"	=> $id_adjective,					"_intro_for_anonymous_or_public" => $_intro_for_anonymous_or_public,				));			} else {						/******* CТРАНИЦА ПОЛЬЗОВАТЕЛЯ ********/							$this->addJs("fancyInput, user");	// Включаем JS				$this->addCss("fancyInput");		// Включаем CSS								// Получаем случайное прилагательное в placeholder							$default_adjective = DefaultAdjective::randomAdjective($ViewedUser->gender);								// Если просматривает сам себя				if ($own_page) {					// Устанавливаем заголовок					$this->htmlTitle("Мои мнения | ".$LoggedUser->getName());										// Подключаем сторонний JS					$this->addJs("//vk.com/js/api/openapi.js", true);										// Подключаем дополнительный JS					$this->addJs("user_own");										// Если пользователю еще не было предложено подписаться на друзей из ВК					if (!$LoggedUser->intro["friends"]) {						// Добавлеям JS просмотра друзей						$this->addJs("friends");												// Показать окно друзей на Ratie						$show_friends = true;												// Пользователю уже были предложены друзья из ВК, больше не отображать						$LoggedUser->intro["friends"] = 1;						$LoggedUser->save();					}										// То отображаем все прилагательные					$Adjectives = Adjective::findAll();										// Подсчитываем кол-во скрытых прилагательных					$hidden_count = Adjective::findAll(array(						"condition"	=> "hidden=1"					), true); 				} else {					// Устанавливаем заголовок					$this->htmlTitle($ViewedUser->getName(), true);										// Иначе не отображаем скрытые					$Adjectives = Adjective::findAll(array(						"condition" => "hidden=0"					));										// Если пользователь залогинен					if (User::loggedIn()) {						// Проверяем подписан ли залогиненынй пользователь на пользователя, чья страница просматривается						$subscribed = User::fromSession()->subscribedTo($ViewedUser->id);												// Сообщения после регистрации о публичности (код сообщения для ангуляра - 1)						if (!$LoggedUser->intro["public"] && !$LoggedUser->anonymous) {							$_intro_for_anonymous_or_public = 1;							$LoggedUser->intro["public"] = 1;							$LoggedUser->save();						}															// Сообщения после регистрации об анонимности (код сообщения для ангуляра - 2)						if (!$LoggedUser->intro["anonymous"] && $LoggedUser->anonymous) {							$_intro_for_anonymous_or_public = 2;							$LoggedUser->intro["anonymous"] = 1;							$LoggedUser->save();						}					}				}												$this->render("userpage", array(					"User"				=> $ViewedUser,					"Adjectives"		=> $Adjectives,					"hidden_count"		=> $hidden_count,					"own_page"			=> $own_page,					"default_adjective"	=> $default_adjective,					"subscribed"		=> $subscribed,					"id_viewing"		=> $ViewedUser->id,					"show_friends"		=> $show_friends,					"_intro_for_anonymous_or_public" => $_intro_for_anonymous_or_public,				));			}		}				// Точно тест		public function actionTest2()		{			$User = User::findById(1);						$Vote = new Vote(array(				"id_adjective"	=> 2,				"ip"			=> "192.168.0.1",			));						$this->render("test2", array(				"Vote" => $Vote,			));		}						// Функция для добавления мысли о человеке		public function actionAjaxAddThought()		{						// Инициализируем сессию для того, чтобы получить ID текущего пользователя, чья страница просматривается			$User = User::findById($_SESSION["viewing_id"]);			$Adjective = $User->addAdjective($_POST["adjective"], true);												}				// Функция голосования		public function actionAjaxVote()		{			// Инициализируем сессию для того, чтобы получить ID текущего пользователя, чья страница просматривается			$User = User::findById($_POST["id_viewing"]);						// Ищем прилагательное			$Adjective = Adjective::findById($_POST["id"]);						// Добавляем голос			$Adjective->addVote(true, $_POST["type"]);		}				// Скрываем прилагательное		public function actionAjaxHide()		{			// Получаем пользователя из сессии			$User = User::fromSession();						// Залогиненный юзер должен быть равен просматриваемому (иначе кто-то другой может будет послать запрос на HIDE прилагательного)			if ($_SESSION["viewing_id"] == $User->id) {				$Adjective = Adjective::findById($_POST["id"]);				$Adjective->hidden = !$Adjective->hidden;				$Adjective->save();			}		}				// Подписываемся		public function actionAjaxSubscribe()		{			// Получаем пользователя из сессии			$User = User::fromSession();			// Подписываемся на пользователя			$User->subscribeTo($_POST["id_user"]);		}				// Получаем список друзей		public function actionAjaxGetFriends()		{			// Массив с ID всех друзей из ВК			/*			foreach ($_POST["ids"] as $id_friend) {				echo $id_friend."\n";			}*/						$condition = implode(",", $_POST["ids"]);						// echo $condition;						$Friends = User::findAll(array(				"condition"	=> "id_vk in ($condition)"			));						// print_r($Friends);						echo json_encode($Friends);					}						// Оставляем комментарий		public function actionAjaxLeaveComment()		{			// Проверяем есть ли комментарий			if (!empty($_POST["comment"])) {				// Инициализируем сессию для того, чтобы получить ID текущего пользователя, чья страница просматривается				$User = User::findById($_POST["id_viewing"]);								// Получаем залогиненного пользователя				$LoggedUser = User::fromSession(false);								/***** Проверяем лимит комментариев подряд от одного пользователя *****/				// Получем последние комментарии				$LastComments = Comment::findAll(array(					"condition" => "id_adjective=".(int)$_POST["id_adjective"],					"order"		=> "id DESC",					"limit"		=> Comment::INAROW_LIMIT,				));								// Подсчитываем количество от текущего пользователя				if ($LastComments) {					$count_limit = 0;					foreach ($LastComments as $Comment) {						if ($Comment->ip != realIp()) {							break;						} else {							$count_limit++;						}					}										// Если превышен лимит 					if ($count_limit >= Comment::INAROW_LIMIT) {						exit("Слишком много комментариев подряд!");										}				}				/************* КОНЕЦ ПРОВЕРКИ МЫСЛЕЙ ПОДРЯД ***************/								$Comment = new Comment(array(					"comment"		=> mysql_escape_string(trim($_POST["comment"])),					"id_adjective"	=> (int)$_POST["id_adjective"],					"id_user"		=> ($LoggedUser->anonymous ? 0 : $LoggedUser->id),					"ip"			=> realIp(),					"time"			=> now(),				));								$Comment->save();								// Возвращаем ID нового комментария				echo $Comment->id;										// Добавляем новость, если это не комментарий самому себе				if ($LoggedUser->id != $User->id) {					Feed::create(array(						"id_adjective"	=> (int)$_POST["id_adjective"],						"id_user"		=> ($LoggedUser->anonymous ? 0 : $LoggedUser->id),						"id_news_type"	=> NewsType::COMMENT,					));					}								}		}				/*		 * Просто получает значения из сессии. Для тестов		 */		public function actionAjaxGetSession()		{			echo json_encode($_SESSION);		}				/*		 * Если пользователь нажал кнопку «Предложить оценить» и успешно поделился записью в ВК		 */		public function actionAjaxAddShare()		{			// Получаем залогиненного пользователя			$LoggedUser = User::fromSession(false);						// Увеличеваем кол-во shares			$LoggedUser->shares++;						// Сохраняем			$LoggedUser->save();		}	}